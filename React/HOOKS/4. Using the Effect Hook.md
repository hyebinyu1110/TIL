### 참조: [React 공식 홈페이지 - HOOKS - Using the Effect Hook](https://reactjs.org/docs/hooks-effect.html)


## Using the Effect Hook(Effect Hooks 사용하기)
- Hooks 는 React 16.8 에서의 새로운 추가 사항입니다. Hooks 는 클래스를 작성하는것 없이 state와 React 의 다른 feature(특징)을 사용하게 합니다. 
~~~ 
    - Effect Hook은 function components 에서 side effects 를 실행하게 합니다.
~~~
~~~Java Script

import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  //  componentDidMount 및 componentDidUpdate 와 유사합니다.
  useEffect(() => {
    // Update the document title using the browser API
    // 브라우저 API를 사용하는 document title을 업데이트 함.
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
~~~
    - 이 예제는 이전 페이지로부터의 counter 예제에 기반을 두고 있습니다만, counter 예제에 새로운 feature 을 추가하였습니다.
    우리는 document title을 사용자가 클릭한 숫자를 포함한 커스텀 메시지로 설정하였습니다.  
   
    - React 컴포넌트에서 data fetching, subscription 설정, 수동으로, DOM을 변경하기는 side effects의 모든 예시입니다. 
    "side effects" (or "effect")를  호출하는 이러한 동작에 당신이 익숙하든지 않든지, 아마도 당신의 컴포넌트에서 이전에 이러한 동작을
    실행하였을 것입니다.


Tip

    - 만약 React의 class 컴포넌트의 lifecycle 메서드에 익숙하다면, useEffect Hook를 componentDidMount, componentDidUpdate,그리고
    componentWillUnmount 가 합쳐진것으로 생각할 수 있습니다.

    - React 컴포넌트에는 두 가지의 흔한 종류의 side effect가 있는데, 하나는 cleanup을 필요로 하지 않고, 나머지는 필요로 합니다.
    이 차이를 더 자세하게 들여다 봅시다. 

## Effects Without Cleanup(cleanup 이 없는 Effects)
    - 때때로, 우리는 React가 DOM을 업데이트 한 후에 몇 추가적인 코드를 실행하고 싶습니다. Network requests, manual DOM mutations, and logging
    은 cleanup을 요구로 하지 않는 흔한 effects의 예제들입니다. 이렇게 이야기 할 수 있는 이유는 이러한 추가적인 코드를 실행하고, 즉시 코드를
    까먹어도 되기 때문입니다. 어떻게 class 컴포넌트와 Hooks 가 우리로 하여금 이러한 side effects를 표현하게 하는지 비교해 봅시다.



## Example Using Classes(class 컴포넌트를 이용한 예제)
    - class 컴포넌트를 이용한 React에서는, render method 자체는 side effects를 발생시키지 않습니다. 그 이유는 너무 일찍이여서 그런데 
    우리는 보통 우리의 effects를 React가 DOM을 업데이트 한 후에 실행하고 싶기때문입니다.

    - 그러한 이유로, React의 class 컴포넌트는 side effects를 componentDidMount and componentDidUpdate에서 실행되도록 하였습니다.
    다시 예제로 돌아와, 여기에 DOM에 변경사항을 만든 바로 후에 document title을 업데이트하는 React의 counter class 컴포넌트를 보여줍니다.

~~~Java Script
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }
  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
~~~

 **우리가 class 컴포넌트에서 어떻게 이러한 두 lifecycle 메서드들 사이의 코드를 복제해야하는지 주목해 주세요**

    - 이것은 많은 경우에 컴포넌트가 금방 마운트 됐는지, 업데이트가 되었는지의 여부와 관계없이 동일한 side effect를 수행하기를
    원하기 때문입니다. 개념적으로 우리는 side effect가 매번 렌더링을 할 때마다 일어나길 원합니다. 그러나 class 컴포넌트는 이러한 기능을
    가진 메서드를 가지고 있지 않습니다. 그래서 우리는 별개의 매서드를 추출해낼수 있지만, 여전히 두 개의 장소에서 메서드를 호출해야 합니다.
    (componentDidMount, componentDidUpdate에서와 같이)
   
    - 이제 useEffect Hook를 이용하여 어떻게 같은 일을 할 수 있는지 봅시다.




## Example Using Hooks(Hook를 이용한 예제)
    - 우리는 이미 이 페이지의 상단에서 이 예제를 보았지만, 좀 더 자세히 살펴 봅시다.
~~~Java Script

import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
~~~
### What does useEffect do?
    - Hook를 이용함으로서, React에게 당신은 rendering 후에 당신의 컴포넌트가 무언가 할 필요가 있다고 말합니다. React는 당신이 전달한 함수를 기억할 것이며, 
    (우리는 전달한 함수를 우리의 "effect"로서 참조할겁니다.) DOM 업데이트를 수행한 후에, effect를 호출할 겁니다. 이 effect 에서, 우리는 document.title에 
    값을 설정하지만, 우리는 또한 data fetching 이나 몇 개의 다른 긴요한 API를 호출할 수 도 있습니다.)


### Why is useEffect called inside a component?
    - useEffect를 컴포넌트 내부에 위치시키는 것은 우리로 하여금 effect에서 바로state 변수인 count 변수에 접근하도록 합니다. 우리는 특별한 API로 state를
    읽기 위해 필요로 하지 않습니다. 왜냐면 state는 이미 함수 스코프에 위치하고 있기 때문이죠. Hooks는 JavaScript 클로저를 받아들이며, JavaScript가 
    이미 해결책을 제공하는곳에 React 특정 API를 도입하는 것을 지양합니다.

  
### Does useEffect run after every render?
    - 네! 기본설정으로, useEffect는 처음으로 렌더링할 때와 매 업데이트가 발생한 후 모두 후에 작동합니다. (나중에 어떻게 이것을 커스텀하는지에 대해 이야기할 겁니다.)
    "mounting"과 "updating"의 면에서 생각하는 대신에, effects 는 렌더링 후에 발생한다라고 생각하는것이 더 쉽다는 것을 알게 될겁니다. React는 컴포넌트가 effects를 실행할 
    쯤에 DOM이 업데이트 되었다는 것을 보장 합니다.


## Detailed Explanation(세부 설명)
    - effects에 대해 더 알게 되었으니 아래의 라인들이 이해 될겁니다.
~~~Java Script

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });
}
~~~

    - 우리는 state 변수인 count를 선언한 후, React에세 effect를 사용할 필요가 있다고 말합니다. useEffect Hook에게 함수를 전달합니다. 우리가 전달한 함수가 우리의 effect 입니다.
    우리의 effect 내부에서, 우리는 document.title browser API를 사용하여 document title를 설정합니다. 우리는 effect 내부에서 가장 최근 업데이트 된 count 값을 읽을수 있는데, 그     이유는 effect 함수의 스코프내에 있기 때문입니다. 우리의 컴포넌트를 React가 렌더링 할 때, 우리가 사용한 effect를 기억하며, DOM을 업데이트 한 후에 우리의 effect를 실행합니다. 
    effect 실행은 제일 처음 렌더링을 포함한  매 렌더링 후에 발생합니다.
 
    - 숙련된 자바스크립트 개발자들은 useEffect로 전달한 함수가 매 렌더링때마다 다를거라는 것을 눈치챌지 모릅니다. 이것은 고의 입니다. 사실 이

Experienced JavaScript developers might notice that the function passed to useEffect is going to be different on every render. This is intentional. In fact, this is what lets us read the count value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render. We will see more clearly why this is useful later on this page.

Tip

Unlike componentDidMount or componentDidUpdate, effects scheduled with useEffect don’t block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don’t need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate useLayoutEffect Hook with an API identical to useEffect.


