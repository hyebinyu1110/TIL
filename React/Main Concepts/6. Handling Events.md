### 참조: React 공식 홈페이지 : [Handling Events](https://reactjs.org/docs/handling-events.html)

## Handling Events(event 처리하기)
 - 이벤트를 React elements로 처리하는 것은 DOM elements에 있는 events를 처리하는 것과 유사합니다. 
 여기에, 구문적인 차이점이 몇 가지 있습니다:
  
    1) React 이벤트는 lowecase 보다는 camelCase를 사용하여 명명되어 집니다. 
    2) JSX로 string 보다는 event handler로서 함수를 전달합니다.
    - 예를 들면, HTML에서의 아래의 코드가 
~~~Java Script
<button onclick="activateLasers()">
  Activate Lasers
</button>
~~~
 
  - React 에서는 약간 다릅니다.
~~~Java Script
<button onClick={activateLasers}>
  Activate Lasers
</button>
~~~

    3) 또 다른 차이점은 React에서 event 의 기본설정 실행을 방지하기위해 false를 반환할수 없다는 것입니다. 
    무조건 preventDefault() 함수를 독점적으로, 호출하여야 합니다. 
    - 예를들어, 평 HTML에서는 submit event 의 기본설정 실행을 방지하기위해서 아래와 같이 코드 작성이 가능합니다.
 ~~~Java Script
<form onsubmit="console.log('You clicked submit.'); return false">
  <button type="submit">Submit</button>
</form>
~~~
    - 리액트에서는, event를 방지하기 위해서 아래와 같이 작성하여야 합니다. 
~~~Java Script
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
    console.log('You clicked submit.');
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}
 ~~~
     - 여기에서, e 는 인위적으로 합성한 event입니다. React는 이러한 인위적으로 합성한 event를 W3C 스펙에 따라 정의합니다.
     그래서 당신은 브라우저 간 호환성을 걱정하지 않아도 됩니다. React event는 native event 와 정확히 동일하게 작동하지 않습니다.
     - 위의 내용을 더 알고 싶다면 아래의 링크를 참조하여 주세요. 
     
- 참조: [SyntheticEvent](https://reactjs.org/docs/events.html)

      
      - React 를 사용할때, 당신은 일반적으로 DOM element가 생성된 후, DOM element 에 대한 listener를 추가하기위해 
      addEventListener를 호출할 필요가 없습니다. 그냥 element가 최초로 rendering 될 때 listener를 제공하세요.
      
      - 당신이 ES6 클래스를 사용하는 컴포넌트를 정의할 때, 일반적인 패턴은 event handler가 클래스에서 method 가 되는 것입니다.
      - 예를 들어, 아래의 Toggle 컴포넌트는 사용자가 "ON"과 "OFF" state 사이에 왔다 갔다 할수 있도록 하는 버튼을 render 합니다.
      - 
When using React, you generally don’t need to call addEventListener to add listeners to a DOM element after it is created.
Instead, just provide a listener when the element is initially rendered.

When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. 
For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states:

class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
Try it on CodePen

You have to be careful about the meaning of this in JSX callbacks. 
In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, 
this will be undefined when the function is actually called.

This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, 
if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.

If calling bind annoys you, there are two ways you can get around this. If you are using the experimental public class fields syntax,
you can use class fields to correctly bind callbacks:

class LoggingButton extends React.Component {
  // This syntax ensures `this` is bound within handleClick.
  // Warning: this is *experimental* syntax.
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
This syntax is enabled by default in Create React App.

If you aren’t using class fields syntax, you can use an arrow function in the callback:

class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      <button onClick={() => this.handleClick()}>
        Click me
      </button>
    );
  }
}
The problem with this syntax is that a different callback is created each time the LoggingButton renders.
In most cases, this is fine. However, if this callback is passed as a prop to lower components, 
those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax,
to avoid this sort of performance problem.

