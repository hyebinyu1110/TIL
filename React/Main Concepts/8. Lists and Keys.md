### 참조: React 공식 홈페이지 : [Lists and Keys](https://reactjs.org/docs/lists-and-keys.html)

## Lists and Keys(List 와 Key)

- 먼저, JavaScript 에서 당신이 어떻게 lists로 변환하는지 살펴봅시다.
~~~
    - 아래의 코드를 고려할 때, 우리는 map()함수로 numbers 배열을 매개변수로 받아 배열의 값을 두 배로 만듭니다. 
    우리는 `doubled` 라는 변수에 map()함수에 의해 반환된 새로운 배열을 대입하고, 배열을 출력합니다.
~~~

~~~Java Script
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((number) => number * 2);
console.log(doubled);
~~~

    - 이 코드는 [2, 4, 6, 8, 10]을 콘솔로 출력합니다. 
    - React에서는 arrays 를 lists of elements 로 변환하는 것이 거의 동일합니다.


## Rendering Multiple Components(여러 개의 components를 렌더링 하기)
    - 당신은 elements의 collection 을 만들어 중괄호({})를 사용하여 JSX에서 elements의 collection 을 포함할 수 있습니다.
    
    - 아래에, 자바스크립트의 map() 함수를 이용하여 numbers array 를 반복적으로 방문합니다.
    - 우리는 배열 각 아이템에 대한 <li> 요소를 반환합니다. 최종적으로, 우리는 반환된 요소들의 배열을 `listItems`로 대입합니다.
   
~~~Java Script
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
  <li>{number}</li>
);
~~~
    - 그리고 나서, 우리는 `listItem` 배열을 `<ul> 요소에 포함시킬 수 있습니다. 

<ul>{listItems}</ul>

    - 이 코드는 1부터 5사이의 있는 숫자들의 bullet list(•)를 보여줍니다.
    • 1
    • 2
    • 3
    • 4
    • 5
    
    
   ## Basic List Component (기본적인 List component)
     - 보통 컴포넌트 내부에 lists 를 렌더링 합니다.
     - 우리는 예전 예시를 재정비 하여, `numbers` 배열을 받아 elements 의 list(<li></li>)를 출력하는 컴포넌트로 만들수 있습니다.
~~~Java Script
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <li>{number}</li>
  );
  return (
    <ul>{listItems}</ul>
  );
}

const numbers = [1, 2, 3, 4, 5];
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<NumberList numbers={numbers} />);
~~~
    - 당신이 이 코드를 실행할 때, list items 에 대한 key 가 제공되어야 한다는 warning(경고)를 받을 것입니다.
    - "key"란 elements의 list를 생성할 때 포함하는 특별한 string 속성입니다. 우리는 다음 섹션에서 이것이 왜 중요한지 
    이야기 할 것입니다.
    
    - `numbers.map()` 내부에 우리의 list items(<li></li>) 에 대한 `key`를 지정하여, key 이슈를 해결합시다.
~~~Java Script
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <li key={number.toString()}>
      {number}
    </li>
  );
  return (
    <ul>{listItems}</ul>
  );
}
~~~

## Keys
- Key 는 React가 어떤 items 가 변경되어 추가되고, 제거되었는지 확인하도록 도와줍니다. 
- Keys 는 배열 내부에 있는 elements에게 주어지는데, elements 에게 stable 한 identity(신원)을 주기위함입니다. 
(요소에 id를 주어 찾을수 쉽게 하도록 함과 똑같은 기능)
~~~Java Script
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
  <li key={number.toString()}>
    {number}
  </li>
);
~~~
    - key를 고르는 가장 최고의 방법은 자매 <li></li> 중에 <li></li> item을 특정하게 신원파악을 할수 있는 문자열을 사용하는 것입니다.
    - 대부분의 경우에 당신의 data 로부터 ID를 key로서 사용할 것입니다.

~~~Java Script
const todoItems = todos.map((todo) =>
  <li key={todo.id}>
    {todo.text}
  </li>
);
~~~
    - 당신이 rendering 되는 item에 대한 stable 한 ID 가 없을 때, 당신은 마지막 수단으로, key로써 item index를 사용할 수 있습니다.
~~~Java Script
const todoItems = todos.map((todo, index) =>
  // Only do this if items have no stable IDs
  // 만약 items 이 어떤 stable ID가 없을 때만 item index를 사용하세요
  <li key={index}>
    {todo.text}
  </li>
);
~~~
    - 만약 items의 순서가 바뀔지도 모른다면 index를 key로서 사용하는 것을 권하지않습니다. 
    - 이것은 성능에 나쁜 영향을 끼칠 수도 있으며, component state에 이슈를 야기할 수도 있습니다.
    - index를 key로서 사용하는 것의 부정적인 영향에 대한 깊이있는 설명이 있는 Robin Porkorny의 기사를 확인해주세요.
    - 만약 당신이 item을 list함에 있어 명확한 key를 지정하지않는 것을 선택한다면, React는 index를 key로서 사용하도록 기본설정할 것입니다.
    - 만약, 당신이 이것에 대해 더 알고 싶다면, 왜 key가 필요한지에 대한 깊이있는 설명을 아래 링크를 참조해 주세요.
    
   - 참조: [Recursing On Children](https://reactjs.org/docs/reconciliation.html#recursing-on-children)


## Extracting Components with Keys(key를 가진 component를 추출하기)
    - key는 오직 배열 내의 문맥에서 이해가 갑니다.
    - 예를 들어, 만약 ListItem 컴포넌트를 추출한 다면, ListItem 그 자체의 <li> 요소에서가 아니라,
      배열에서 <ListItem /> 요소에 key를 유지해야합니다.
    - 예시 -> 틀린 key 사용
~~~Java Script
function ListItem(props) {
  const value = props.value;
  return (
    // Wrong! There is no need to specify the key here:
    <li key={value.toString()}>
      {value}
    </li>
  );
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    // Wrong! The key should have been specified here:
    <ListItem value={number} />
  );
  return (
    <ul>
      {listItems}
    </ul>
  );
}
~~~

Example: Correct Key Usage

function ListItem(props) {
  // Correct! There is no need to specify the key here:
  return <li>{props.value}</li>;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    // Correct! Key should be specified inside the array.
    <ListItem key={number.toString()} value={number} />
  );
  return (
    <ul>
      {listItems}
    </ul>
  );
}
Try it on CodePen

A good rule of thumb is that elements inside the map() call need keys.

Keys Must Only Be Unique Among Siblings
Keys used within arrays should be unique among their siblings. However, they don’t need to be globally unique. We can use the same keys when we produce two different arrays:

function Blog(props) {
  const sidebar = (
    <ul>
      {props.posts.map((post) =>
        <li key={post.id}>
          {post.title}
        </li>
      )}
    </ul>
  );
  const content = props.posts.map((post) =>
    <div key={post.id}>
      <h3>{post.title}</h3>
      <p>{post.content}</p>
    </div>
  );
  return (
    <div>
      {sidebar}
      <hr />
      {content}
    </div>
  );
}

const posts = [
  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
  {id: 2, title: 'Installation', content: 'You can install React from npm.'}
];

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<Blog posts={posts} />);
Try it on CodePen

Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:

const content = posts.map((post) =>
  <Post
    key={post.id}
    id={post.id}
    title={post.title} />
);
With the example above, the Post component can read props.id, but not props.key.

Embedding map() in JSX
In the examples above we declared a separate listItems variable and included it in JSX:

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    <ListItem key={number.toString()}
              value={number} />
  );
  return (
    <ul>
      {listItems}
    </ul>
  );
}
JSX allows embedding any expression in curly braces so we could inline the map() result:

function NumberList(props) {
  const numbers = props.numbers;
  return (
    <ul>
      {numbers.map((number) =>
        <ListItem key={number.toString()}
                  value={number} />
      )}
    </ul>
  );
}
Try it on CodePen

Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the map() body is too nested, it might be a good time to extract a component.








