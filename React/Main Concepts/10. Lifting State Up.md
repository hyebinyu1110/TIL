### 참조: React 공식 홈페이지 : [Lifting State Up](https://reactjs.org/docs/lifting-state-up.html)

## Lifting State Up(state를 상위 컴포넌트로 올리기)
    - 종종, 몇 컴포넌트는 같은 changing data 를 반영하여야 합니다. 그렇기에 우리는 공유하는 state를 그들에게 가장 가까운 
      공통 조상 컴포넌트로 올리는 것을 추천합니다. 이것이 어떻게 행동으로 작동하는지 한 번 봅시다.

    - 이 섹션에서, 주어진 온도에서 물이 끓을지 말지 계산하는 온드 계산기를 생성할 것입니다.

    - BoilingVerdict 라고 하는 component로 시작해봅시다. BoilingVerdict는 prop으로 celsius 온도를 받아들이고, 온도가 
     물을 끓이기에 충분한지 아닌지 보여줍니다.

~~~Java Script
function BoilingVerdict(props) {
  if (props.celsius >= 100) {
    return <p>The water would boil.</p>;
  }
  return <p>The water would not boil.</p>;
}
~~~
    - 다음으로, 우리는 Calculator라고 하는 component를 생성할 겁니다. Calculator는 <input> HTML 태그를 보여주고, 
    당신으로 하여금 온도를 작성하게 하여, this.state.temperature 에 value를 기록합니다. 
    
    - 추가적으로, Calculator 는 현재의 입력 value 에 대해서 BoilingVerdict 를 렌더링합니다.
    
~~~Java Script
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    return (
      <fieldset>
        <legend>Enter temperature in Celsius:</legend>
        <input
          value={temperature}
          onChange={this.handleChange} />
        <BoilingVerdict
          celsius={parseFloat(temperature)} />
      </fieldset>
    );
  }
}
~~~

## Adding a Second Input(두번째 input 을 추가하기)
    - 우리의 새로운 요구사항은 Cesius 을 위한 <input>에 더하여, Fehrenheit <input>을 제공하는 것입니다. 
      Cesius와 Fahrenheit 는 동기화되어 있습니다.
      
    - 우리는 Calculator 로부터 TemperatureInput 컴포넌트를 추출함으로써 시작할 수 있습니다. 우리는 scale이라는 새로운 
    prop을 TemperatureInput에 추가할 것인데, prop은 "C"나 "F" 둘 중 하나를 가질 것입니다. 

~~~Java Script
const scaleNames = {
  c: 'Celsius',
  f: 'Fahrenheit'
};

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    const scale = this.props.scale;
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}:</legend>
        <input value={temperature}
               onChange={this.handleChange} />
      </fieldset>
    );
  }
}
~~~
    - 우리는 이제 두 개의 별개의 온도 입력을 rendering 하기위해 Calculater 컴포넌트를 변경할 수 있습니다.

~~~Java Script
class Calculator extends React.Component {
  render() {
    return (
      <div>
        <TemperatureInput scale="c" />
        <TemperatureInput scale="f" />
      </div>
    );
  }
}
~~~
     - 우리는 두 개의 <input>을 현재 가지고 있지만, 두 개의 <input> 중 하나에 온도를 입력할 때, 그 나머지는 상태를 업데이트 하지 않습니다.
     - 이 모순은 우리의 요구사항에 반합니다. 우리는 이 두 <input>이 동기화되기를 원합니다.
     
     - 또한 우리는 Calculator 에서 BoilingVerdict 컴포넌트를 보여줄 수 없습니다. Calculator 컴포넌트는 현재의 온도를 모르기 때문인데,  
     그 이유는 TemperatureInput 내부에 숨겨져 있기때문입니다.


## Writing Conversion Functions(변환 함수 적기)
    - 먼저, 우리는 Celsius 로부터 Fahrenheit 로 변환하고 그 반대로도 변경하기위해 두 개의 함수를 적을 것입니다.
~~~Java Script
function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}
~~~

    - 이 두 개의 함수는 숫자를 변환합니다. 우리는 인자로 문자열로 된 온도와 converter 함수를 인자로 받아 문자열을 반환하는 또 다른 함수를
    작성할 것입니다.
    - 우리는 다른 <input> 에 기반으로한 <input>의 값을 계산하는데 위의 함수를 사용할 겁니다.
  
    - 위의 함수는 유효하지 않은 온도에 대해서 빈 깡통 문자열을 반환하며, 함수는 반환값(output)을 소숫점이하 세 자리까지로 반올림되게 
    유지할것입니다.

~~~Java Script
function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) {
    return '';
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}

~~~
    - 예를들어, tryConver('abc', toCelsius) 는 빈 문자열을 반환하며, tryConvert('10.22', toFahrenheit)는 '50.396'
    을 반환합니다. 


## Lifting State Up
    - 현재,  TemperatureInput 컴포넌트 둘 다 독립적으로 지역 state에 그들의 value 를 보관합니다.
~~~Java Script
class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    // ...  
~~~

    - 그러나, 우리는 이 두 input이  서로 동기화되기 원합니다. 우리가 Celsius <input>을 업데이트 할 때, Fahrenheit <input>은 변환된 온도를
    반영해야 합니다. 그 반대로도 마찬가지 입니다.
    
    - React 에서는, state를 공유하는 것은 state를 필요로 하는 공통된 조상 컴포넌트에 state를 이동시킴으로써 성취됩니다.
    - 이것이 "lifting state up" 이라고 불립니다. 우리는 지역 변수를 TemperatureInput으로부터 제거하고 대신에 Calculator 컴포넌트로
    이동시킬겁니다.
    
    - 만약 Calculator 컴포넌트가 공유하는 state 를 소유한다면, 그 shared state는 두 <input>에서 현재의 온도에대한 
     "source of truth" 가 됩니다.
    - "source of truth" 는 서로 같은 value 를 가지도록 알려줄 수 있습니다.
    - TemperatureInput 컴포넌트 둘 다의 props 가 같은 부모인 Calculator 컴포넌트로부터 오기 때문에, 두 <input>은 항상 동기화되어 있을겁니다.
    
    - 동기화가 어떻게 단계적으로 작동하는지 봅시다.

    - 먼저 우리는 TemperatureInput 컴포넌트에서 this.state.temperature 를 this.props.temperature 로 바꿀 겁니다.
    - 현재, this.props.temperature 가 이미 존재한다고 생각합시다.
    (나중에 Calculator 컴포넌트로부터 this.props.temperature 를 전달할 필요가 있지만요)

~~~Java Script
  render() {
    // Before: const temperature = this.state.temperature;(이전)
    const temperature = this.props.temperature;(이후)
    // ...
 ~~~
     - 우리는 props 가 읽기전용이라는 것을 압니다. temperature 가 지역 state 에 있을 때, TemperatureInput은 지역 state를 변경하기위해 
     this.setState() 를 그냥 호출하였습니다.
     - 그러나, 지금은 temperature 가 prop 으로서 부모 컴포넌트에서 전달받기때문에, TemperatureInput은 props을 통제할 권한이 없습니다.
    
    - React 에서, 이 문제는 보통 컴포넌트를 "controlled" 되게 만듬으로써 해결될수 있습니다. DOM <input> 과 똑같이, value와 onChange 
    라는 prop 둘 다  받아들입니다.
    - 그래서 사용자 정의 TemperatureInput이 부모 컴포넌트인 Calculator 로 부터 props 인 temperature(변수)와 onTemperature(함수) 둘 다 
    받아들일 수 있습니다.
 
    - 이제는, TemperatureInput이 자신의 temperature을 업데이트 하고 싶을때, this.props.onTemperatureChange 를 호출합니다.
~~~Java Script
  handleChange(e) {
    // 이전: this.setState({temperature: e.target.value});
    this.props.onTemperatureChange(e.target.value); // 이후
    // ...
    
~~~
Note:

- 사용자 정의 컴포넌트에 있는 `temperature`와 `OnTemperatureChange`의 prop 이름에는 어떤 특별한 의미가 없습니다.
- 이 두 props 들을 다른 이름으로 호출했을수도 있습니다.(흔한 관례인, `value` 와 `onChange` 로 이름지을수 있습니다.)

~~~
    - prop 인 onTemperatureChange 는 다른 prop인 temperature 와 함께 부모 컴포넌트인 Calculator 에 의해 제공될 것입니다.
    - onTemperatureChange는 자신의 지역 state를 수정함으로써, 변경내용을 처리할 것입니다. 따라서 새로운 values 로 <input> 둘 다
    렌더링 할 것입니다.
    - 우리는 곧 새로운 Calculator 컴포넌트의 구현을 살펴볼 것입니다.
    

    - Calculator 컴포넌트에 있는 변경사항을 살펴보기전에, TemperatureInput 컴포넌트에 대한 변경을 복습해 봅시다.
    - 우리는 local state를 컴포넌트로부터 제거한 후, this.state.temperature 값을 읽는 대신, 이제 this.props.temperature 값을
    읽습니다.
    - state를 변경하고 싶을 때 this.setState() 함수를 호출하는 대신, 이제 우리는 this.props.onTemperatureChange() 함수를 호출하며,
    이 함수는 부모인 Calculator 컴포넌트로부터 제공 될 것입니다.

~~~Java Script

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(e) {
    this.props.onTemperatureChange(e.target.value);
  }

  render() {
    const temperature = this.props.temperature;
    const scale = this.props.scale;
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}:</legend>
        <input value={temperature}
               onChange={this.handleChange} />
      </fieldset>
    );
  }
}

~~~

    - 이제 Calculator 컴포넌트로 넘어갑시다.
    - 우리는 현재 <input>의 temperature와 scale을 Calculator 의 지역 state에 저장할 겁니다. 이것이(local state) 우리가 inputs로부터 
    lifted up" 한 state 이며, 이 state 는 temperature 와 scale  모두에 대한 "source of truth" 역할을 할 것입니다. 

    - 두 input 모두 다 rendering 하기 위하여 우리가 알 필요가 있는 모든 데이터에 대한 최소한의 묘사(representation)입니다.
    
    - 예를 들어, 우리가 Celsius <input>에 37을 입력한 다면, Calculator 컴포넌트의 state는 아래와 같이 될겁니다.

~~~Java Script

{
  temperature: '37',
  scale: 'c'
}
~~~~
    - 우리가 나중에 Fahrenheit 필드를 212가 되게 수정한다면, Calculator 컴포넌트의 state는 아래와 같이 될겁니다.
 ~~~Java Script

{
  temperature: '212',
  scale: 'f'
}
~~~~

    - 우리는 <input> 의 값 둘 다 저장할 수도 있었지만 필요없는 것으로 밝혀졌습니다. 가장 최근에 변경된 <input>의 value와 scale을 대변하는 값을 저장
    저장하는 것만으로 충분합니다.
    - 그러면 우리는 단독으로 현재의 temperature 와 scale 에 기반하여 다른 input의 value를 추론할 수 있습니다.
    
    - <input>들은 서로 동기화 되어있는데 그 이유는 input 들의 value가 같은 state로부터 계산되었기 때문입니다.
    (The inputs stay in sync because their values are computed from the same state:)

~~~Java Script

class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
    this.state = {temperature: '', scale: 'c'};
  }

  handleCelsiusChange(temperature) {
    this.setState({scale: 'c', temperature});
  }

  handleFahrenheitChange(temperature) {
    this.setState({scale: 'f', temperature});
  }

  render() {
    const scale = this.state.scale;
    const temperature = this.state.temperature;
    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;

    return (
      <div>
        <TemperatureInput
          scale="c"
          temperature={celsius}
          onTemperatureChange={this.handleCelsiusChange} />
        <TemperatureInput
          scale="f"
          temperature={fahrenheit}
          onTemperatureChange={this.handleFahrenheitChange} />
        <BoilingVerdict
          celsius={parseFloat(celsius)} />
      </div>
    );
  }
}
~~~

Now, no matter which input you edit, this.state.temperature and this.state.scale in the Calculator get updated. One of the inputs gets the value as is,
so any user input is preserved, and the other input value is always recalculated based on it.

Let’s recap what happens when you edit an input:

React calls the function specified as onChange on the DOM <input>. In our case, this is the handleChange method in the TemperatureInput component.
The handleChange method in the TemperatureInput component calls this.props.onTemperatureChange() with the new desired value. 
Its props, including onTemperatureChange, were provided by its parent component, the Calculator.
When it previously rendered, the Calculator had specified that onTemperatureChange of the Celsius TemperatureInput is the Calculator’s handleCelsiusChange method, 
and onTemperatureChange of the Fahrenheit TemperatureInput is the Calculator’s handleFahrenheitChange method. 
So either of these two Calculator methods gets called depending on which input we edited.
Inside these methods, the Calculator component asks React to re-render itself by calling this.setState() with the new input value 
and the current scale of the input we just edited.
React calls the Calculator component’s render method to learn what the UI should look like. 
The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here.
React calls the render methods of the individual TemperatureInput components with their new props specified by the Calculator.
It learns what their UI should look like.
React calls the render method of the BoilingVerdict component, passing the temperature in Celsius as its props.
React DOM updates the DOM with the boiling verdict and to match the desired input values. The input we just edited receives its current value,
and the other input is updated to the temperature after conversion.
Every update goes through the same steps so the inputs stay in sync.

Lessons Learned
There should be a single “source of truth” for any data that changes in a React application. 
Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, 
you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, 
you should rely on the top-down data flow.

Lifting state involves writing more “boilerplate” code than two-way binding approaches, but as a benefit, 
it takes less work to find and isolate bugs. Since any state “lives” in some component and that component alone can change it, 
the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.

If something can be derived from either props or state, it probably shouldn’t be in the state. For example, 
instead of storing both celsiusValue and fahrenheitValue, we store just the last edited temperature and its scale. 
The value of the other input can always be calculated from them in the render() method. 
This lets us clear or apply rounding to the other field without losing any precision in the user input.

When you see something wrong in the UI, you can use React Developer Tools to inspect the props and move up the tree 
until you find the component responsible for updating the state. This lets you trace the bugs to their source:

Monitoring State in React DevTools

