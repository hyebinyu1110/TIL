### 참조: React 공식 홈페이지 : [Forms](https://reactjs.org/docs/forms.html)

## Forms(Form)
- HTML form 요소는 React에서 다른 DOM 요소들과는 조금 다르게 작동합니다. 왜냐면 form 요소는 자연스럽게 몇가지 내부적인 
 state를 유지하기 때문입니다. 예를 들면, 평 HTML 에서 아래의 form 요소는 오직하나의 name 을 허용합니다.

~~~Java Script
<form>
  <label>
    Name:
    <input type="text" name="name" />
  </label>
  <input type="submit" value="Submit" />
</form>
~~~
    - 이 form은 새로운 페이지로 브라우징하는 기본적인 HTML form의 동작을 가지고 있는데, 사용자가 form을 submit할 때 발생합니다.
    - 만약 당신이 React 에서 이 동작을 원한다면, 그대로 작동합니다. 그러나 대부분의 경우에, form의 제출을 처리하는 자바스크립트
    함수를 가지는 것과 또, 사용자가 form에 입력한 데이터에 접근할 수 있는 것이 편리합니다.
    - 이것을 성취하는 표준적인 방법은 "controlled components"(제어된 component) 라고 불리는 테크닉을 가지는 것입니다. 

## Controlled Components(제어된 components)
    - HTML 에서는 <input>, <textarea>,<select> 와 같은 form 요소는 그들 자신의 state 를 유지하여, 사용자 input에 기초하여 업데이트 합니다.
    - 리액트에서는 변경가능한(mutable) state(상태)는 일반적으로 컴포넌트의 state 속성으로 보관되며, seteState() 을 통해서만 업데이트 됩니다.
    (뭔말이야~~~)
    - 우리는 HTML과 React 둘 을 React state가 진실의 단일 근원이 되게 함으로써 합칠 수 있습니다.
    - 그리고나서, form을 렌더링하는 React 컴포넌트는 또한 뒤따르는 사용자의 입력값에 따라, form에서 무슨 일이 발생하는지는 제어합니다.
    - 이 방식으로 React에 의해 값이 제어되는 input form 요소는  "controlled component: 라고 불립니다.

    - 예를 들어, 만약 우리가 form이 submit될 때,  이전 예시를 출력되게 만들고 싶다면, controlled component 로서 form을 작성할 수 있습니다.
~~~Java Script
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
~~~

    - value 속성은 우리의 form 요소에서 설정되기 때문에, React state를 the source of truth(??)로 만듦으로써,
    보여지는 value는 항상 this.state.value 가 될 것입니다.
    - handleChange는 React state를 업데이트하기 위해 키보드를 누를 때 마다 실행되고, 보여지는 값은(input 창에) 
    사용자가 타이핑할때 업데이트 할 것입니다.
    
    - 제어되는 component로, input 요소의 value는 항상 React state의 값에 의해 동작합니다.  이로인해 당신이 코드를 조금 더 작성해야 한다더라도,
    value를 다른 UI 요소에게 이제 전달 할 수 있습니다. 또는 다른 event 핸들러로 reset 할 수 있습니다.

## The textarea Tag(Textarea 태그)
    - HTML에선, <textarea> 요소는 자신의 자식요소에 의해 자신의 text를 정의합니다.
~~~Java Script

<textarea>
  Hello there, this is some text in a text area
</textarea>
~~~
    - React 에선, <textarea>는 value 속성을 대신에 사용합니다. 이 방식으로, <textarea>를 사용하는 form은  단일 라인의 input 을 
    사용하는 form과 매우 유사하게 작성될수 있습니다.
~~~Java Script
class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 'Please write an essay about your favorite DOM element.'
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('An essay was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Essay:
          <textarea value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}

~~~
    - this.state.value는 constructor에 의해 초기화 되었다는 것을 명심하세요. 그래야 textarea는 textarea에 this.state.value의 
    값을 가지고 시작될 수 있습니다.

## The select Tag(select 태그)
    - HTML 에서, <select> 는 drop-down 리스트를 생성합니다. 예를 들어, 이 HTML의 flavors에 대한  드랍다운 리스트를 생성합니다.
~~~Java Script

<select>
  <option value="grapefruit">Grapefruit</option>
  <option value="lime">Lime</option>
  <option selected value="coconut">Coconut</option>
  <option value="mango">Mango</option>
</select>
Note that the Coconut option is initially selected, because of the selected attribute. React, instead of using this selected attribute, uses a value attribute on the root select tag. This is more convenient in a controlled component because you only need to update it in one place. For example:

class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: 'coconut'};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('Your favorite flavor is: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Pick your favorite flavor:
          <select value={this.state.value} onChange={this.handleChange}>
            <option value="grapefruit">Grapefruit</option>
            <option value="lime">Lime</option>
            <option value="coconut">Coconut</option>
            <option value="mango">Mango</option>
          </select>
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
~~~

Overall, this makes it so that <input type="text">, <textarea>, and <select> all work very similarly - they all accept a value attribute that you can use to implement a controlled component.

Note

You can pass an array into the value attribute, allowing you to select multiple options in a select tag:

<select multiple={true} value={['B', 'C']}>


