<Web4 - Express Session & Auth>

1. 수업소개

- 쿠키가 등장하면서, 요청과 응답이라는 단순한 의사소통만이 가능했던  웹이 이전에 통신했던 내용을 기억할 수 있게 됨.
- 덕분에 개인화, 인증과 같은 중요한 혁신의 발판이 됨.
- 쿠키통해서 인증하는 것 위험 -> 유출, 조작 위험이 있음

- 세션 아이디의 값 -> 길고 복잡. 여기서 어떤 정보를 얻어낼 수 있나? 없다.
왜? 정보가 없기 때문이다. 이 정보는 각각의 사용자를 식별하기위한 의미없지만, 사용자를 식별하는 식별자로서 기능하는 것. 이것에 대한 실제 정보는 세션스 디렉터리에 파일로 만들어지도록 이고잉이 구현해 놓은 상태 그리고 로그인 했을 때, isLogined 값이 true 가 됨.즉, 로그인이 된 상태. 그 사용자의 닉네임이 이고잉이라고 하는 정보가 저장된 것을 볼 수 있음. 사용자가 로그인에 성공했는지 안했는지 그리고 사용자의 닉네임이라든지, 사용자 마지막 접속시간 등 이런 정보가 세션스 디렉터리 안에 은밀하게 서버쪽에 저장하고, 그리고 사용자의 웹브라우저에는 이 데이터가 이 데이터의 주인인지 아닌지를 체크할 수 있는 식별자만을  저장하는 걸 통해, 훨씬 더 안전하게 훨씬 더 많은 정보를 유지할 수 있도록 구현할 수 있도록하는 것이 session 이다. 현대적인 애플리케이션들은 쿠키를 통해 직접 인증을 구현하지않고, 쿠키는 사용자를 식별하는데만 사용하고, 실제 데이터는 서버쪽에 안전하게 파일이나 DB의 형태로 저장하는 것으로 구현하는 것이 세션 방법이다. 
- 우리는 지금부터 세션을 통해 보다 안전한 애플리케이션을 구현하는 방법을 살펴 볼것이다. 
- 준비됐나요? 출발합시다. 

2.예제 구동

- 직접 구현 가능, 보안에 나의 인생을 갈아넣을 의지가 없다면, 그것말고 내가 해야할일이 따로 있다면, 직접 구현하지 말고, 전문가들이 직접 구현해 놓은 것을 사용하고, 자주 업데이트를 하는 것이 훨씬 좋은 방법. 물론 직접 구현해보는것도 좋은 것이겠지만요.

- 그래서 라이브러리를 사용함.
- Express로 들어옴
- Express에서 플러그인을 미들웨어라고 함. (express-session) 
- Express에서 express-session을 추천하지만, 웹사의 내용이 오래된 내용일 수 있으니 구글로 검색해보기

- Nodemon 사용함 (pm2와 비슷) 참조: https://backend-intro.vlpt.us/1/03.html
- 노드몬은 pm2와 똑같이 꺼지면 켜주는 파일이 수정되면 리로드 해주는 역할을 하는데, 좀 더 간편하고 이렇게 메시지를 기본적으로 보여주기 때문에, 편하다. 
- 리로드할때마다 카운트가 증가하는데 그 이유는 세션 때문이다. 
- application-cookie 탭에 가면 session id, 사용자를 식별하는 쿠키값이 만들어져서 서버에 접속할때마다 웹브라우저가 서버쪽으로 전송해줌. 서버는 저 쿠키 값을 가지고 저 쿠키값에 해당되는 사용자의 데이터를 조작하는 것을 통해, 1씩 값을 증가시키고 있는 것. 


3. 옵션

- session 을 쓰기위해서는 express-session 이라고 하는 미들웨어를 모듈로서 설치를 하고, app.use를 하면 사용자요청이 있을때마다 이 코드를 실행하도록 약속이 되어 있음. 
- session 함수를 실행시키면 세션이 시작되는 것이다. 저 미들웨어가 내부적으로 개입해서  우리 애플리케이션이 세션에 사용할 수 있도록 작업처리 
- session 함수에 객체를 전달하게 되면, 저 객체 안에 이러한 값에 따라 세션이 동작하는 기본적인 동작방법을 바꿀수 있게 됨.  


4. session 객체

- session 미들웨어는 이것을 설치했을 때 , 이 미들웨어가 내부적으로 조용히, request객체의 프로퍼티로 session 이라고 하는 객체를 추가해주는 것이다. 
- ·· 백틱이 grave accent 라고도 불린다. 
- default값이 메모리 스토리, nodejs 를 끄면 메모리의 정보가 사라짐. 다시켰을 때, 리로드를 하면 값이 다시 1부터 시작됨. 즉, 휘발되는 것이다. 

- 이런 경우 사용자가 다 로그아웃 됨. 휘발되지 않는 곳에 사용자 정보를 저장하는 것이 낫다. 

5. session store

- 세션 스토어(저장소) 다변화 하는 방법을 알아 볼 것이다. 기본적으로 메모리고, 메모리는 휘발된다. 
- Compatible Session Stores
- 세션 미들웨어는 일개 미들웨이지만, 방대한 생태계를 가지고 있다. 
- 여러 가지 DB, 저장방법들 마다 모듈들이 쪼개어져 있다. 
- session-file-store(https://www.npmjs.com/package/session-file-store)
- express-session 미들웨어가 무슨일을 하는가
- 사용자가 session id를 가지고 있는 상태에서 서버로 접속하면 , request headers 쪽에 쿠키 값으로 서버 세션 아이디를 전달함. 
-Cookie: connect.sid=s%3AkdgNXa5ZpmhOu3nh3ZYs8Qq1D7qXTfoY.OjGFefHB466hVw%2FYuuodCi1Kk%2BaRhFjUxq0TlJl0W%2FM

- 세션 미들웨어가 저 아이디 값을 가지고, 세션 스토어에서 적당한, 저 아이디 값에 대응되는 파일을 읽음. 
- 거기에 있는 데이터를 기반으로 하여, request 객체의 세션이라고 하는 프로퍼티에 객체를 추가하는 것이다. 그리고 거기에 있는 값중에 num이 3니까, 3으로 세팅해서 공급해줌. 
- request 가 끝난다음에 session 미들웨어가 이 파일에다가 그 값을 적고,  작업을 끝냄.
- 다음에 요청할 때 이 파일을 열어서, 세션 객체를 통해 그 데이터를 공급해 줌.
- 그과정에서 session store를 사용하는 것이고, 요것을 파일이 아닌, MySQL을 사용하면 MySQL을 session store로 사용할 수 있다. 이것이 session middleware를 사용하는데 있어 필요한 원리 또는 사용법이라 할 수 있다. 


6.1. 인증구현 - UI 만들기



6.2. 인증구현 - 로그인 세션구현
- 로그인을 했을 때, 사용자가 전송한 ID와 PSWD를 post로 받아서 그것을 인증하는 기능을 구현
- 사용자의 아이디와 비번, 닉네임을 위쪽에 적어
- 비밀번호가 소스코드에 있으면, 소스코드를 공개했을때, 비번이 딸려 갈수 있기 때문에, 비번을 소스코드바깥으로 빼내는 방법을 모색해봐야 한다. 
- 그리고 비번을 평문으로 저장 하는 것은 ‘죄’ 예요. ‘죄’,  절대로 그러시면 안됩니다!
- 이것도 역시 마찬가지로 해쉬라던지, 비밀번호 암호화,라는 주제로 검색하셔서, 비밀번호를 관리하는 관리자 들도,  볼 수 없도록 하는 작업을 꼭! 해야 한다. 
- 한 사람의 사용자의 인증을 하는 시스템을 만들었지만, 여기에 여러사람의 인증시스템도 여러분이 잘 생각해보시면 할 수 있을거라고 기대하겠습니다. 


6.3. 인증구현 - 세션 미들웨어 설치
· 세션은 파일시스템 보다는 DB나 캐싱DB에 저장하는게 훨씬 더 바람직하다.
- 세션을 실제로 미들웨어로서 앱에다 설치하는 코드 main.js에 추가하기.
- 애플리케이션을 접속할 때 마다 세션이 생성 된다. 
- 로그인시, 접속했을 때, 우리의 웹서버가 응답헤더로 ,set-cookie에 connect.sid는 무엇 무엇라고 하는 세션의 식별자를 쿠키의 형식으로 웹브라우저에 박아넣고, 그 다음에 이 세션아이디에 해당되는 매칭되는 파일을 서버쪽에 저장을 했고, auth.js에 작성한 2줄의 코드로 인해 
request.session.is_logined = true;
request.session.nickname = authData.nickname;

세션 파일에는 보시는 것처럼 nickname은 hyebinyu1110, isLogined 는 true라는 값이 저장이 된다. 
- 다시 웹 어플리케이션에 저장할 때, 웹브라우저는 세션 아이디를 다시 우리가 만든 어플리케이tus으로  전송한다. 
- 그러면 세션미들웨어는 저 값에 따라, 세션아이디에 따라 파일시스템에 같은 이름을 가진 파일에 접근할 수 있도록 세션객체를 구워 줄겁니다. 
- response.redirect(`/`); // 세션 데이터를 만드는 코드가 오면 된다.



6.4. 인증구현 - 인증상태를 UI에 반영
- 현재 로그인에 성공한 상태, 로그인 성공여부를 확인하고, login->logout 으로 변경하고, logout앞에 로그인 사용자의 이름을 넣으려고 한다.


6.5. 인증구현 - 로그인상태 UI를 반영 2
- auth 와 관련된 함수를 별도의 파일로 분리함. 



6.6. 인증구현 - 로그아웃
- 로그아웃은 정보를 보낼 필요가 없기 때문에 get 방식으로 하면 됨.
- request.session.destroy(callback함수)
- 기존에 있던 session 파일은 사라졌고, 사용자는 더 이상 isLoggedIn이 true인 상태가 아니게 되니까, 여기에 있는 logout이라고 되어 있던 버튼이 login으로 바뀐것을 볼수 있음.


6.7. 인증구현 - 접근제어
- 로그인되지 않은 상태에서 생성과 삭제 안되도록 함.
- 세션 미들웨어를 이용하여 사용자 로그인 및 로그아웃하고 자신의 권한에 따라, 적절한 페이지 접근 가능할지 않을지 결정하는 기능을 가지고 있는 웹 애플리케이션을 구현하는 작업을 모두 끝냄. 
 


왜 자꾸 connect.sid가 로그인 안했는데도 생성되는거지???

6.8. 인증구현 - 세션저장
- 우리가 property 를 주면 , 코드들이 다 실행된 후, 세션 미들웨어는 우리 대신에 우리 기록한 데이터를 세션스토어에 기록하는 작업을 시작함. => 메모리에 저장된 세션데이터를 저장소에 다가 반영하는 작업을 나중에 함. 저장소가 어떤 이유로 인해 굉장히 느려짐. 한 시간이 걸림. 한시간동안 작업하는 중에 그 와중 리다이렉션 작업은 순식간에 끝나버리니 아직 세션 스토어에 저장도 안햇는데 리다이렉션이 끝나버리면, 나는 분명히 로그인을 했는데, 로그인이 안되어있다고 화면이 뜨면, 1시간 뒤에 접속해보니 그때 로그인이 되어있다 나올수 도 있다. 
- 그때 사용하는 것이 세션 객체의 세이브 함수 
-request.session.save();

- 세션객체에 있는 데이터를 이 함수가 세션 스토어에 적용하는, 반영하는 작업을 바로함.
그리고 그작업이 모두 끝나면, 인자로 전달된 콜백함수를 호출하도록 약속되어 있다. 
- 그 콜백함수가 호출되었을때 리다이렉션을 실행함으로서, 스토어에 반영작업이 끝난 후에 사용자를 리다이렉션할수 있게 되는 것임.


7. 수업을마치며

- HTTP 이용해 웹서버와 라우터 통신을 하고 있음 http 로 통신하고 있다는 것은 누군가 우리의 통신을 보고 있다는 것으로 간주해야함.
- 세션 아이디를 도둑 맞는 다면 우리 대신 로그인 가능함 
- 현실에서는 꼭 https를 이용해서, 통신을 해야함. 세션의 option 으로 secure: true,로 하면 https 에서만 통신을 주고 받도록 설정할 수 있음
- 사용자가 전송한 데이터에서 자바스크립트를 사용할 수 없게 해야한다. 또 , httponly 옵션을 두면 자바스크립트를 통해 세션쿠키를 사용할 수 없도록 강제 할 수 있다. 
- 회원이 많아지면, 애플리케이션의 복잡성 높아짐. 비밀번호 잃어버렸을 때의 대안마련 등등 다중사용자 수용하는 서비스에 도전해보는것도 좋다. 
- 구글, 트위터의 회사의 회원정보 이용해 인증을 하도록 할 수 도 있다. 타사의 회원정보를 두고, 자사에서 회원에 대한 식별만을 하는 인증방법을 federation authentication 이라 한다. 
- 고도의 주의가 관리되는 작업을 구글에 맡기고, 자사는 회원이 식별자만을 유지함으로써 보안사고를 방지할 수 있는 굉장히 중요한 효과를 가짐.
- Oauth를 이해하면 타사 인증을 쉽게 구현할 수 있음. 
- 이를 대신해 주는 도구, nodejs에서는 인증 라이브러리 passport.js 이용하면 직접타사 인증을 구현하는것 보다 훨씬 쉽게 이를 구현할 수 있다. 인증을 구현하려고 한다면 추천 
- 이 강의를 보고 있을때 더 좋은 라이브러리가 있을 수 있기떄문에 , 잘 한번 검색해보기

- 이번 여행은 어떠셨나요?

- 경계, 고민, 수련

- 중요한 골격은 다 집어드린것같아요. 축하드립니다. 





























